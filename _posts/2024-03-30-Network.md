---
layout: single
categories:
  - iOS
tags:
- ios
title: "네트워트 계층과 데이터 평면"
comments: true
---

## 네트워크 계층과 데이터 평면

<hr/>

네트워크 계층은 서로 상호작용하는 데이터 평면(data plane)과 제어 평면(control plane)으로 나눌 수 있다. 



네트워크 계층의 근본적인 역할은 단순하다. 송신 호스트에서 수신 호스트로 패킷을 전달하는 것이다. 이를 위한 네트워크 계층의 중요한 기능 두가지는 다음과 같다.

포워딩

패킷이 라우터의 입력 링크에 도달했을 때 라우터는 그 패킷을 적절한 출력 링크로 이동시켜야 한다. 호스트A가 호스트B에서 패킷을 전송한다고 하자. 전송할 패킷이 라우터 R1에 도달했을 때, 라우터 R1은 호스트B로 가는 경로상에 있는 다음 라우터로 패킷을 포워딩(전달)한다. 포워딩에서 가장 중요한 기능은 네트워크 계층의 데이터 평면에서 실행된다. 포워딩은 매우 짧은 시간 단위(보통 ns)를 갖기에 하드웨어에서 실행된다.

라우팅

송신자가 수신자에게 패킷을 전송할 때 네트워크 계층은 퍀시 경로를 결정해야 한다. 이러한 경로를 계산하는 알고리즘을 라우팅 알고리즘이라 한다. 이러한 패킷 전송 라우팅은 네트워크 계층의 제어 평면에서 실행된다. 라우팅은 네트워크 전반에 걸쳐 출발지에서 목적지까지 데이터그램의 종단 간 경로를 결정하는 것이다. 라우팅은 상대적으로 큰 시간 단위(보통 s)를 갖기에 보통 소프트웨어에서 실행된다.

네트워크라우터에서 필수 불가결한 요소는 포워딩 테이블이다. 라우터는 도착하는 패킷 헤더의 필드값을 조사하여 패킷을 전달한다. 이 값을 라우터의 포워딩 테이블의 내부 색인으로 사용한다. 포워딩 테이블 엔트리에 저장되어 있는 헤더의 값은 해당 패킷이 전달해야 할 라우터의 외부 링크 인터페이스를 나타낸다. 네트워크 계층 프로토콜에 따라 헤더의 값은 패킷의 목적지 주소이거나 패킷이 속한 링크의 방향이다.

라우터의 네 가지 구성요소는 다음과 같다.

입력 포트 : 물리 계층 기능을 수행하며, 입력포트는 들어오는 링크의 반대편에 있는 링크 계층과 상호 운용하기 위해 필요한 링크 계층 기능 또한 수행한다. 가장 중요한 것은 입력 포트에서 검색 기능을 수행하는 것이다. 이 때 포워딩 테이블을 참조하여 도착도니 패킷이 스위치 구조를 통해 라우터 출력 포트를 결정한다. 제어 패킷(예를 들어 라우팅 프로토콜 정보를 전달하는 패킷)은 입력 포트에서 라우팅 프로세서로 전달된다.

스위치 구조 : 라우터의 입력포트와 출력 포트를 연결한다.

출력 포트 : 스위치 구조에서 수신한 패킷을 저장하고 필요한 링크 계층 및 물리 계층 기능을 수행하여 출력 링크로 패킷을 전송한다.

라우팅 프로세서 : 제어 평면 기능을 수행한다. 라우팅 프로토콜을 실행하고 라우팅 테이블과 연결된 링크 상태 정보를 유지 관리하며 라우터의 포워딩 테이블을 계산한다. SDN 라우터에서 라우팅 프로세서는 원격 컨트롤러와 통신하여 원격 컨트롤러에서 계산된 포워딩 테이블 엔트리를 수신하고 라우터의 압력 포트에 이러한 엔트리를 설치한다.

데이터 평면이 나노초 단위로 작동하는 동안 라우터의 제어 기능(라우팅 프로토콜 실행, 원격 컨트롤러와 통신 및 관리 기능 수행)은 밀리초 또는 2초 단위로 작동한다. 따라서 이러한 제어 평면 기능은 일반적으로 소프트웨어로 구현되며 라우팅 프로세서(일반적으로 기존 CPU)에서 실행된다.

라우터의 입력처리 과정

라인 종단 -> 데이터 링크 처리(프로토콜, 역캡슐화) -> 검색, 포워딩, 큐잉 -> 스위치 구조

입력포트의 라인 종단 기능과 링크 계층 처리는 라우터의 개별 입력 링크와 관련된 물리 계층 및 데이터 링크 계층을 구현한다. 입력 포트에서 수행되는 검색은 라우터 동작의 핵심이다. 라우터는 포워딩 테이블을 사용하여 도착 패킷이 스위치 구조를 통해 전달되는 출력 포트를 검색한다. 포워딩 테이블은 라우팅 프로세서(다른 네트워크 라우터의 라우팅 프로세서와 상호작용하기 위해 라우팅 프로토콜 사용)에서 계산되거나 갱신되거나 원격 SDN 컨트롤러에서 수신된다. 포워딩 테이블은 라우팅 프로세서에서 입력 라인 카드로 복사된다. 각 라인 카드에서 이와 같은 섀도 복사본을 사용하면 패킷 단위로 중앙 집중식 라우팅 프로세서를 호출하지 않게 되고, 따라서 병목 현상을 피할 수 있다.

포워딩 테이블에서 라우터는 패킷의 목적지 주소의 프리픽스(prefix)를 테이블의 엔트리와 매치한다. 매치되는 엔트리가 존재하면 라우터는 패킷을 그 매치에 연관된 링크로 보낸다. 만일 다수의 매치가 있는 경우 최장 프리픽스 매치 규칙을 사용해 테이블에서 가장 긴 매치 엔트리를 찾고, 여기에 연관된 링크 인터페이스로 패킷을 보낸다.

검색을 통해 패킷의 출력 포트가 결정되면 패킷을 스위치 구조로 보낼 수 있다. 일부 설계에서는 다른 입력 포트로부터 패킷이 현재 구조를 사용하고 있다면 패킷이 스위칭 구조에 들어가는 것을 일시적으로 차단할 수 있다. 차단된 패킷은 입력 포트에 대기한 다음 나중에 구조를 교체하도록 예약된다.

스위치 구조는 패킷이 입력 포트에서 출력 포트로 실제로 스위칭(포워딩)되는 구조를 통과하므로 라우터의 핵심이다. 스위칭을 수행하는 방법으로는 메모리를 통한 스위칭, 버스르 통한 스위칭, 상호연결 네트워크를 통한 스위칭이 있다. 가장 단순한 초기의 라우터는 CPU(라우팅 프로세서)를 직접 제어해서 입력 포트와 출력 포트 사이에서 패킷을 스위칭하는 전통적인 컴퓨터다. 입력 포트와 출력 포트는 전통적인 운영체제에서 전통적인 I/O 장치처럼 작동한다. 패킷이 도착하면 입력 포트는 라우팅 프로세서에게 인터럽트를 보내 패킷을 프로세서 메모리에 복사한다. 그런 다음 라우팅 프로세서는 헤더에서 목적지를 주소를 추출하고 포워딩 테이블에서 적절한 출력 포트를 찾은 다음 패킷을 출력 포트의 버퍼에 복사한다. 이 시나리오에서 메모리 대역폭이 초당 최대 B인 패킷을 메모리에 쓰거나 메모리에서 읽을 수 있는 경우 전체 전달 처리량(패킷이 입려 포트에서 출력 포트로 전동되는 총 속도)은 B/2보다 작아야 한다. 또한 목적지 포트가 다른 경우라도 공유 시스템 버스를 통해 한 번에 하나의 메모리 읽기/쓰기 작업을 수행할 수 있기 때문에 두 패킷을 동시에 전달할 수 없다. 일부의 최근 라우터는 메모리를 통해 스위칭한다. 그러나 초기 라우터와는 주요 차이점은 목적지 주소를 검색하고 해당 메모리 위치에 패킷을 저장하는 것이 입력 라인카드에서 처리함으로써 수행된다는 것이다. 어떤 면에서는 메모리를 통해 스위칭하는 라우터는 공유메모리 멀티프로세서와 매우 흡사하다. 라인 카드에서 패킷을 처리하여 적절한 출력 포트의 메모리로 스위칭(쓰기)한다. 버스를 통한 교환에서 입력 포트는 라우터 프로세서의 개입 없이 공유 버스를 통해 직접 출력 포트로 패킷을 전송한다. 이는 일반적으로 미리 준비된 입력 포트 스위치 내부 레이블(헤더)이 로컬 출력 포트를 나타내는 패킷에게 전송되거나 버스에 패킷을 전송하여 수행된다. 모든 출력 포트에 패킷이 수신되지만 레이블과 매치되는 포트만 패킷을 유지한다. 레이블은 스위치 내에서 버스를 통과하기 위해서만 사용되므로 출력 포트에서 제거된다. 동시에 여러 패킷이 다른 입력 포트에 있는 라우터에 도착하면 한 번에 하나의 패킷만 버스를 통과할 수 있기 때문에 하나를 제외한 모든 패킷이 대기해야 한다. 모든 패킷이 하나의버스를 건너가야 하므로, 라우터의 교환 속도는 버스 속도에 의해 제한된다. 원형 교차로에서 한 번에 하나의 자동차만이 돌 수 있는 것과 유사하다. 그럼에도 불구하고 버스를 통한 스위칭은 종종 작은 지역 및 기업 네트워크에서 작동하는 라우터에서 사용하기에 충분하다. 공유 버스의 대역폭 제한을 극복하는 한 가지 방법은 이전의 멀티프로세서 컴퓨터 구조에서 프로세서를 상호연결하는 데 사용된 것과 같은 좀 더 복잡한 상호연결 네트워크를 사용하는 것이다. 크로스바 스위치(N개의 입력 포트를 N개의 출력 포트에 연결하는 2N 버스로 구성된 상호연결 네트워크)에서 각 출력 버스는 교차점에서 각 입력 버스와 교차하며 스위치 구조 컨트롤러에 의해 언제든지 열거나 닫을 수 있다. 패킷이 포트 A에 도착하여 포트 Y로 전달되어야 하는 경우, 스위치 컨트롤러는 A와 Y 버스들과 포트 A의 교차로에서 교차점을 닫고, 버스로 패킷을 전달한다. 이는 Y 버스만으로 픽업한다. A에서 Y로, B에서  X로의 패킷들은 다른 입출력 버스를 사용하므로 B 포트에서의 패킷은 동시에 X로 전달될 수 있다. 따라서 이전의 두 가지 스위칭 방식과는 달리 크로스바 스위치는 여러 패킷을 병렬로 전달할 수 있다. 크로스바 스위치는 출력 포트로 전달되는 패킷을 다른 패킷이 현재 해당되는 출력 포트로 전달되지 않는 한 해당 출력 포트에 도달하는 것을 차단하지 않는다. 그러나 2개의 서로 다른 입력 포트에서 나오는 2개의 패킷이 동일한 출력 포트로 보내지는 경우 한번에 하나의 패킷만 특정 버스에서 전송될 수 있기 때문에 입력을 기다려야 한다. 좀 더 정교한 상호연결 네트워크는 다단계 스위치 구조를 통해 각기 다른 입력 포트의 패킷이 동일한 출력 포트를 향해 동시에 전달할 수 있도록 여러 단계의 스위칭 요소를 사용한다. 라우터의 스위칭 용량은 다중 스위치 구조를 병렬로 실행하여 확장 가능하다. 이 방식에서는 입력 포트와 출력 포트가 병렬로 작동하는 N개의 스위치 구조에 연결된다. 입력 포트는 패킷을 K개의 작은 청크로 분해하고 이 N개 스위치 구조와 K를 통해 청크를 선택한 출력 포트로 보낸다. 이 출력 포트는 K개의 청크를 다시 원래의 패킷으로 재조합한다.

입력 및 출력 라인의 속도(전송률)이 모두 초당 L패킷으로 동일한 전송률을 갖고 있고, N개의 입력 포트와 N개의 출력 포트가 있다고 핮. 모든 패킷의 고정 길이가 같고 패킷이 동기식으로 입력 포트에 도착한다고 가정하면, 임의의 링크상에서 패킷을 송신하는 시간은 임의의 링크상에서 패킷을 수신하는 시간과 동일하고, 그러한 시간 간격 동안 0또는 하나의 패킷이 입력 링크상에 도착할 수 있다. 패킷이 입력 포트에서 출력 포트로 이동할 수 있는 속도로 스위치 구조 전송률은 S로 정의한다. 만약 S가 L보다 N배 빠르다면, 입력 포트에서 발생하는 큐인은 무시한다. 이는 최악의 경우에도 모든 N 입력 라인이 패킷들을 수신하고 모든 패킷이 같은 출력 포트에 전달되는 곳에서 N 패킷들(입력 포트당 1개의 패킷)의 배치 작업은 다음 배치 작업이 도착하기 전에 스위치 구조를 통해 삭제될 수 있기 때문이다.

입력 큐잉

지연 없이 구조를 통해 도착하는 모든 패킷을 전송하기에 스위치 구조가 충분히 빠르지 않으면 패킷이 스위치 구조를 통해 출력 포트로 전송되기 위해 차례를 기다려야 한다. 이 큐잉의 중요한 결과를 살펴보기 위해 크로스바 스위치 구조를 가정해보자. (모든 링크의 속도는 같다, 입력 링크가 패킷을 받는 것과 같은 속도로 하나의 패킷을 입력 포트에서 주어진 출력 포트로 전달한다, FCFS 방식으로 패킷은 입력 큐에서 출력 큐로 이동된다. 출력 포트가 다르다면 여러 패킷이 병렬로 전달될 수 있지만, 두 패킷이 같은 출력 큐로 향한다면 이 중 한 패킷은 차단되고 입력 큐에서 기다려야 한다. 즉 스위치 구조는 한 번에 하나의 패킷만 지정된 출력 포트로 전송이 가능하다.) x 입력 포트에서 X 출력 포트로 패킷을 보내고 있다고 하자. 이때 y 입력 포트로 들어온 1번 패킷이 X 출력 포트로 패킷을 보내기 위해 큐잉된다. y 입력 포트로 뒤이어 들어오는 2번 패킷은 Y 출력 포트로 전달된다 할지라도 라인의 앞쪽에서 다른 패킷이 막고 있으므로 스위치 구조를 통해 전송되기 위해 기다려야 한다. 이 현상을 HOL(Head-Of-theLine) 차단(blocking)이라고 한다.

출력 큐잉

스위치 구조 전송률이 입출력 라인의 전송률보다 N배 빠르며 N개의 입력 포트 각각에 도착하는 패킷이 동일한 출력 포트로 향한다고 하자. 이 경우, 출력 링크에 단일 패킷을 보내는 데 걸리는 시간에 N개의 새로운 패킷이 출력 포트(N개의 입력 포트 각각에서 하나씩)에 도착한다. 출력 포트는 시간 단위(패킷 전송 시간)에 단일 패킷만을 전송할 수 있기 때문에 N개의 도착 패킷은 출력 링크를 통한 전송 큐에서 대기해야 한다. 그러면 대기 중인 N개의 패킷 중에서 하나를 전송할 때 다시 N개의 새로운 패킷이 도착할 수 있다. 따라서 스위치 구조가 포트 라인 속도보다 N배 빠른 경우에도 패킷 큐잉이 출력 포트에서 발생할 수 있다. 결국 대기 중인 패킷의 수가 출력 포트에서 사용 가능한 메모리를 다 소모할 만큼 충분히 많아질 수 있다.

들어오는 패킷을 저장할 메모리가 충분하지 않을 때 도착한 패킷을 삭제(drop-tail 정책)하거나 이미 대기 중인 하나 이상의 패킷을 제거하여 새로 도착한 패킷을 저장하기 위한 공간을 확보해야 한다. 어떤 경우에는 버퍼가 가득 차기 전에 패킷을 삭제(또는 헤더를 마킹)하여 송신자에게 혼잡 신호를 제공하는 것이 바람직할 수 있다. 이 마킹은 명시적 혼잡 알림(ECN, Explicit Congestion Notification)비트를 사용하여 수행할 수 있다. 현재 AQM(Active Queue Management) 알고리즘으로 알려진 많은  패킷 삭제와 패킷 마킹 정책이 분석되고 있다. 시각 t에서 패킷은 각각의 입력 포트에 도달하고 각각의 포트는 맨 앞의 출력 포트로 향한다. 동일한 라인 속도를 가지고, 라인 속도의 n배(즉, 패킷을 수신 또는 전송하는 데 필요한 시간)로 동작하는 것으로 가정하면 기존의 패킷 n개가 모두 출력 포트로 전송되어 대기 중일 것이다. 이 n개의 패킷 중 하나는 다음번에 출력 라인을 통해전송될 것이다. 전송된 패킷 중 하나는 맨 앞 출력 포트로 전송된다. 이러한 큐잉의 결과는 출력 포트의 패킷 스케줄러가 전송 대기 중인 패킷 중 하나의 패킷을 선택해야 한다는 것이다.

버퍼링이 클수록 라우터가 패킷 도착 속도의 큰 변동을 흡수하여 라우터의 패킷 손실률을 감소시킬 수 있기 때문에 버퍼링이 무조건적으로 좋다고 생각하기보다는 버퍼가 클수록 큐잉 지연이 길어지는 것도 고려해야 한다. 예를 들어, 게임을 하는 사용자의 경우 수십 밀리초가 소요된다. 패킷 손실을 줄이기 위해 홉당 버퍼의 양을 10배 늘리면 종단 간 지연이 10배만큼 증가한다. 이러한 지연 기반 고려사항은 버퍼링이 양날의 검임을 보여준다. 

패킷 스케줄링

라우터에서 일반적으로 사용되는 큐잉 처리 방법은 FCFS(First-Come-First-Served) 방식이다. 링크가 현재 다른 패킷을 전송 중이면 출력 링크 큐에 도착한 패킷은 전송을 기다린다. 도착한 패킷을 담을 버퍼 공간이 충분하지 않은 경우 도착 패킷의 공간을 확보하기 위해 큐의 패킷 폐기 정책은 패킷 손실 여부 도는 다른 패킷을 큐에서 제거할 것인지 여부를 경정한다. FCFS(또는 FIFO) 스케줄링 규칙은 출력 링크 큐에 도착한 순서와 동일한 순서로 출력 링크에서 전송할 패킷을 선택한다. 또 다른 큐잉 처리 방식으로는 우선순위 큐잉이 있다. 우선순위 큐잉에서 출력 링크에 도착한 패킷은 큐에 도착하면 우선순위 클래스로 분류된다. 실제로 네트워크 오퍼레이터는 네트워크 관리 정보를 운반하는 패킷이 사용자 트래픽보다 우선순위를 수신하도록 큐를 구성할 수 있다. 예를 들어 VoIP 패킷은 전자메일 패킷과 같은 트래픽보다 우선순위를 받을 수 있다. 각 우선순위 클래스에는 일반적으로 고유한 큐가 있다. 전송할 패킷을 선택할 때 우선순위 큐는 전송 대기 중인 패킷으로 차 있는 상태이고 가장 높은 우선 순위 클래스에서 패킷을 전송한다. 우선순위가 동일한 패킷들 중에서의 선택은 전형적으로 FIFO 방식으로 행해진다. 라운드 로반 큐잉 규칙에서 패킷은 우선순위 큐잉과 같이 클래스로 분류된다. 그러나 클래스 간에는 엄격한 서비스 우선순위가 존재하지 않으며, 라운드 로빈 스케줄러가 클래스 간에 서비스를 번갈아서 제공한다. 가장 단순한 라운드 로빈 스케줄링에서는 클래스1 패킷이 전송된 다음 클래스2 패킷이 전송되고, 다시 클래스 1패킷 다음에 클래스2 패킷이 전송된다. 작업 보존 큐잉(work-conserving queuing) 규칙의 경우, 전송을 위해 큐에서 기다리는 패킷이 있다면 링크는 유휴 상태가 되는 것을 허용하지 않는다. 작업 보존 라운드 로빈 규칙에서는 클래스에서 패킷을 찾기만 아무것도 찾지 못하면 시퀀스의 다음 클래스를 즉시 검사한다. 예를 들어 패킷 1, 2, 4는 클래스1에 속하며 패킷3, 5는 클래스2에 속한다고 하자. 패킷1은 출력 큐에 도착하면 즉시 전송을 시작한다. 패킷 1이 전송되는 동안 패킷2, 3이 도착하고 전송을 대기한다. 패킷 1의 전송이 완료되면 링크 스케줄러는 클래스2 패킷을 찾고 패킷3을 전송한다. 패킷3의 전송이 완료되면 스케줄러는 클래스 1 패킷을 찾고 패킷2를 전송한다. 패킷2의 전송이 완료되면 패킷4만이 큐에 있기 때문에 바로 패킷4를 전송한다. 라우터에서 널리 구현된 라운드 로빈 큐잉의 일반화된 형태는 소위 WFQ(Weighted Fair Queuing) 규칙이다. WFQ에서 도착하는 패킷은 적절한 클래스별 대기 영역에서 분류되며 대기한다. 라운드 로빈 스케줄링에서처럼 WFQ 스케줄러는 순환 방식으로 동작한다. 클래스가 3개 있다고 가정했을 때, 먼저 클래스1이 동작하고 클래스2 이후 클래스3이 동작하는 패턴 작업을 반복한다. 또한 WFQ는 작업 보존 큐잉 규칙이며, 따라서 빈 클래스 큐를 찾으면 서비스 순서에서 다음 클래스로 즉시 이동한다. WFQ는 각 클래스마다 다른 양의 서비스 시간을 부여받는다는 점에서 라운드 로빈과 차이가 있다. 특히 각 클래스 i는 가중치Wi를 할당받는다. WFQ에서는전송할 클래스i 패킷이 있는 동안에 클래스i는 Wi / 가중치의 합의 서비스 시간을 보장받는다. 최악의 경우에 모든 클래스가 큐에 패킷이 있을 때도 클래스 i는 대역폭 Wi / 가중치의 합만큼을 사용할 수 있도록 보장받는다. 따라서 설명한 WFQ는 이상적인 것인데, 그 이유는 패킷이 이상적인 단위 데이터라는 것과 패킷 전송이 다른 패킷을 전송하기 위해 방해되지 않는다는 사실을 고려하지 않았기 때문이다.