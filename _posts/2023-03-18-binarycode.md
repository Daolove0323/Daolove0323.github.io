---
layout: single
categories:
  - ComputerStructure
title: "2진수"
---

### 10진수를 n진수로 변환
10진수를 n진수로 변환하려면 수의 몫을 계속 n으로 나누며, 나머지를 모으면 된다.    
예를 들어 10진수 58을 5진수로 변환한다고 하자.    
```
58을 5로 나누면 몫 11, 나머지 3    
11을 5로 나누면 몫 2, 나머지 1    
2를 5로 나누면 몫 0, 나머지 2    
```
가 되고, 나머지 3, 1, 2를 역순으로 붙힌 213이 58을 5진수로 변환한 값이다.    

### n진수를 10진수로 변환
거꾸로 n진수를 10진수로 변환하 값은 각 자리수의 숫자와 자리수의 곱의 합이다.    
예를 들어 5진수 213을 10진수로 변환한다고 하자.    
213(5) = 2 * 5^2 + 1 * 5^1 + 3 & 5^0    
이므로 50 + 5 + 3 = 58이 된다.    

### 소수에서의 변환
10진수 소수를 n진수 소수로 변환하는 것도 위와 비슷한다.    
대신 수를 n으로 나누는 것이 아닌 곱을 반복하며 정수를 모으면 된다.    
이 때 소수가 0이 되거나 자릿수의 개수가 충분할때까지 반복한다.    
예를 들어 10진수 0.6875를 2진수로 변환한다고 하자.    
```
0.6875 * 2 = 1.375, 정수 1, 소수 0.375    
0.375 * 2 = 0.75, 정수 0, 소수 0.75    
0.75 * 2 = 1.5, 정수 1, 소수 0.5    
0.5 * 2 =. 1.0, 정수 1, 소수 0    
```
가 되고, 정수 1, 0, 1, 1를 붙힌 0.1011이 0.6875를 2진술 변환한 값이다.    

정수 부분과 소수 부분을 둘 다 가진 경우, 정수와 소수를 개별적으로 반환하고 둘을 결합한다.    

### 2진수, 8진수, 16진수의 변환
8은 2^3, 16은 2^4이기 때문에 2진수, 8진수, 16진수는 서로 변환이 간단하다.    
2진수 3개씩 묶어서 변환하면 8진수, 4개씩 묶어서 변환하면 16진수가 된다.    
예를 들어 (001 011 111 110 . 111 101 000 110)(2)를 8진수로 변환하기 위해 . 좌우로 3개씩 묶어서 8진수로 바꾸면 1376.7506이 된다.    
마찬가지로 이 숫자를 16진수로 표현하려면 0010 1111 1110 . 1111 0100 0110이 되므로 , 2fe.f46이 된다.    
8진수, 16진수에서 2진수로의 변환은 반대로 하면 된다.    

### 보수
n진수 r자리의 숫자 N에 대해 (n-1)의 보수는 (n^r - 1) -N으로 정의한다.    
또한 같은 수에 대해 n의 보수는 n^r - N(N != 0)이고, N이 0일 경우 0으로 정의한다.    
예를 들어 10진수 12345에 대한 9의 보수는 87654이며 10의 보수는 87655이다.    

2진수에서 1의 보수는 0을 1로 1을 0으로 변환하면 되고, 2의 보수는 1의 보수에 1을 더하면 된다.    
또한 보수한 값을 원래대로 되돌리려면 보수의 보수를 취하면 된다.    

### 보수를 통한 부호없는 두 수의 마이너스 연산
보수를 이용하면 마이너스 연산을 할 수 있다.    
피감수 M에 감수 N에 대한 r의 보수를 더하면(n은 N의 자리수).   
M + (r^n - N) = M - N + r^n 이다.    
이때, M >= N 이라면 최종자리올림(r^n)을 생성할 것이며 이것은 버리게 되면 결과는 M - N이다.    
M < N 이라면 M - N + r^n의 합에 대한 r의 보수를 구하고, - 부호를 붙힌다. (2진수의 1의 보수, 2의 보수 체계에서 M -N + 2^n의 합은 이미 음수표현이다.)        
양의 정수의 뺄셈은 (r - 1)의 보수를 통해서도 수행할 수 있다.    
(r - 1)의 보수는 r의 보수보다 1이 작다. 따라서  M >= N 인 경우, 최종자리올림을 제거하고 1을 더해주어야 한다.    
M < N 인 경우에는 마찬가지로 합에 대한 보수를 구하고 - 부호를 붙힌다.    

### 2진수의 음수표현
이진수의 음수표현은 다음 세가지가 있다.    
2의 보수 방식(Signed 2's Complement) - 2의 보수로 바꾸어 음수를 표현    
1의 보수 방식(Signed 1's Complement) - 1의 보수로 바꾸어 음수를 표현    
부호 크기 방식(Signed magnitude) - 가장 왼쪽 비트의 값을 1로 바꾸어 음수를 표현    

부호 크기 방식은 부호와 크기를 분리해서 다뤄야해서 컴퓨터의 산술 연산에 적합하지 않다.    
1의 보수 방식은 마이너스 연산시 1을 더해주어야 하는 번거로움이 있다.    
또 위 두방식은 0이 두 개(+0, -0)이라는 단점이 있다.    
하지만 1의 보수는 1을 0으로, 0을 1로 바꾸는 논리 보수 연산과 동일하므로 논리연산으로는 유용하다.    

2진수의 보수 방식에서는 음수또한 양수와 동일한 방식으로 덧셈, 뺄셈 연산을 한다.    
즉 컴퓨터는 두 형식의 산술 연산에 단 하나의 하드웨어 회로를 필요로 하고, 따라서 보수 방식은 컴퓨터 시스템의 거의 모든 산술 연산 장치에서 사용된다.    

### BCD 코드
BCD(Binary Coded Decimal) 코드는 4비트를 이용해 10진수를 표현한 방식이다. (1은 0001, 2는 0010, 3은 0011 등)
135를 BCD 코드로 표현하면 0001 0011 0101 이다.    
그런데 같은 135를 2진수로 표현하면 1000 0111 이다.    
BCD 코드는 12비트인 반면 2진수는 8비트이다.    
즉 BCD 코드는 같은 수를 표현하기 위해 2진수보다 더 많은 비트를 사용한다.    
이는 BCD 코드를 통해 표현하는 10진수가 2의 배수가 아니기 때문에 1010부터 1111까지 6개의 값을 낭비하기 때문이다.    
또한 6개의 값이 유효하지 않기에 연산에도 어려움이 있다.    
예를 들어 9 + 4를 BCD 코드로 연산해보자.    
1001 + 0100 = 1101의 결과가 나오는데 1101은 BCD코드에서 유효하지 않는 값이다.    
즉 BCD코드에서 덧셈 시 값이 1001(9) 보다 크다면 0110(6)을 더해주어야 한다.    

### 아스키 코드
아스키 코드(ASCII, American Standard Code for Information Interchange)는 7비트를 이용해 128개의 문자를 코드화한 것이다.    
예를 들어 문자 A는 아스키 코드로 100 0001, 9는 아스키 코드로 011 1001이다.    
이 외에도 특수문자(!, ?), 제어문자(NULL, BS(Backspace)) 등을 포함하고 있다.    

### 오류 검출 코드
데이터 통신에서 오류를 검출하기 위해 아스키 코드에 8번째 비트를 추가한다.    
이를 패리티 비트(parity bit)라고 하는데, 1의 개수를 홀수나 짝수로 맞추기 위함이다.    
짝수 패리티에서는 1의 개수가 짝수, 홀수 패리티에서는 1의 개수가 홀수개여야 하는데, 이를 통해 데이터 통신에서 오류를 검출할 수 있다.    
만일 홀수 패리티에서 1의 개수가 짝수라면, 1개, 3개와 같이 홀수 개의 오류가 발생한 것이다.    
만일 짝수개의 오류가 발생한다면 오류를 검출하지 못한다.    
```
예를 들어 아스키 코드 A(100 0001)을 짝수 패리티하면 0100 0001이 된다.       
마찬가지로 아스키 코드 S(101 0011)을 홀수 패리티하면 1101 0011이 된다.    
```


